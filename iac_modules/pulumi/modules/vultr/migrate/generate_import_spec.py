#!/usr/bin/env python3
"""Generate Pulumi import specifications for Vultr resources."""

from __future__ import annotations

import argparse
import json
import shutil
import subprocess
from pathlib import Path
from typing import Iterable, List, Tuple

Resource = Tuple[str, str, str]


def check_cli_available(executable: str) -> None:
    if shutil.which(executable) is None:
        raise SystemExit(
            f"The '{executable}' CLI is required but was not found in PATH."
        )


def run_json_command(command: Iterable[str]) -> dict:
    result = subprocess.run(
        list(command),
        check=True,
        capture_output=True,
        text=True,
    )
    stdout = result.stdout.strip()
    if not stdout:
        return {}
    return json.loads(stdout)


def discover_instances() -> List[Resource]:
    cmd = ["vultr-cli", "instance", "list", "--output", "json"]
    data = run_json_command(cmd)
    instances = data.get("instances", []) if isinstance(data, dict) else []

    instance_ids = []
    for instance in instances:
        instance_id = instance.get("id") or instance.get("ID")
        if instance_id:
            instance_ids.append(instance_id)

    return [
        ("vultr:instance:Instance", f"instance-{instance_id}", instance_id)
        for instance_id in sorted(instance_ids)
    ]


def discover_object_storage() -> List[Resource]:
    cmd = ["vultr-cli", "object-storage", "list", "--output", "json"]
    data = run_json_command(cmd)
    buckets = data.get("object_storages", []) if isinstance(data, dict) else []

    bucket_ids = []
    for bucket in buckets:
        bucket_id = bucket.get("id") or bucket.get("ID")
        if bucket_id:
            bucket_ids.append(bucket_id)

    return [
        ("vultr:objectStorage:Bucket", f"object-storage-{bucket_id}", bucket_id)
        for bucket_id in sorted(bucket_ids)
    ]


def build_import_spec(resources: Iterable[Resource]) -> dict:
    return {
        "resources": [
            {"type": r_type, "name": name, "id": resource_id}
            for r_type, name, resource_id in resources
        ]
    }


def write_import_commands(resources: Iterable[Resource], output_path: Path) -> None:
    lines = [
        "#!/usr/bin/env bash",
        "set -euo pipefail",
        "",
        "# Generated by generate_import_spec.py",
        "",
    ]
    for r_type, name, resource_id in resources:
        lines.append(f"pulumi import {r_type} \"{name}\" \"{resource_id}\"")

    output_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    output_path.chmod(0o755)


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--spec-output",
        default="import-spec.json",
        type=Path,
        help="Path to write the generated import specification JSON",
    )
    parser.add_argument(
        "--commands-output",
        default="import-commands.sh",
        type=Path,
        help="Path to write the generated pulumi import commands script",
    )

    args = parser.parse_args()

    check_cli_available("vultr-cli")

    resources: List[Resource] = []
    resources.extend(discover_instances())
    resources.extend(discover_object_storage())

    spec = build_import_spec(resources)
    args.spec_output.write_text(
        json.dumps(spec, indent=2, sort_keys=True) + "\n",
        encoding="utf-8",
    )

    write_import_commands(resources, args.commands_output)

    print(
        f"Generated {len(resources)} resources in {args.spec_output} "
        f"and {args.commands_output}."
    )


if __name__ == "__main__":
    main()
